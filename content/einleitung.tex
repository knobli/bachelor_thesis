%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Project     : Bachelorarbeit
% Title       : Machbarkeitsanalyse für eine ressourcenorientierte Schnittstelle zur Verarbeitung grundlegender Probleme der Informatik
% File        : einleitung.tex Rev. 01
% Date        : 01.03.2015
% Author      : Raffael Santschi
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Theoretische Grundlagen}\label{chap.einleitung}
Die theoretischen Grundlagen dient dazu, wichtige Informationen zum Verständnis der Arbeit zu erläutern. Es werden die Komplexitätsklassen der theoretischen Informatik und die verschiedenen 
Algorithmentypen erklärt.

\section{Komplexitätsklassen der theoretischen Informatik}\label{cat_theo_inf}
In der theoretischen Informatik wird zwischen verschiedenen Komplexitätsklassen unterschieden. In diesem Kapitel werden nur auf die Komplexitätsklassen NP, P, NP-schwer und 
NP-vollständig eingegangen, weitere Klassen wie zum Beispiel Random Polynomial (RP) oder Zero-Error, Probabilistic, Polynomial (ZPP) werden nicht erläutert, da sie nicht für das Verständnis der 
Arbeit notwendig sind. Die nachfolgenden Erklärungen sind aus \cite{hopcroft2011einfuehrung} und \cite{slides_p_np} abgeleitet.

\subsection{NP}\label{np}
Falls die Korrektheit einer Lösung zu einem Problem in \gls{polynomialzeit} überprüft werden kann, liegt das Problem in NP. Die Prozedur, welche für die Überprüfung benötigt wird, 
wird \gls{polynomialzeit_verifizierer} genannt.  In \gls{polynomialzeit} lösbar heisst, dass die Laufzeitkomplexität in einem Polynom mit der Form $n^k$ dargestellt werden kann, wobei n die 
Eingabelänge und k eine Konstante ist.

\subsection{P}\label{p_complet}
Probleme, welche in \gls{polynomialzeit} mit Hilfe einer \glslink{deterministisch}{deterministischen} \gls{turingmaschine} lösbar sind, gehören zu der Klasse der P-vollständigen Probleme.

\subsection{NP-schwer}\label{np_hard}
Probleme, welche nicht in \gls{polynomialzeit} lösbar sind, gehören zu den NP-schweren Problemen. Sie besitzen eine Laufzeitkomplexität höher als polynomial haben, zum Beispiel 
$k^n$ (exponentiell) oder $n!$ (faktoriell). Um zu beweisen, dass das Problem NP-schwer ist, wird versucht ein anderes bekanntes NP-schweres Problem auf dieses Problem zu reduzieren. Mit 
diesem Beweis wird gezeigt, dass das Problem mindestens so schwer wie das andere Problem ist.

\subsection{NP-vollständig}\label{np_complet}
Stephen Cook hat mit dem Beweis der NP-Vollständigkeit des SAT-Problems \cite{cook_complexity} die Grundlage für den Beweis der NP-Vollständigkeit vieler weiterer Probleme 
gelegt. Damit ein Problem als NP-vollständig gilt, müssen folgende zwei Punkte erfüllt sein:
\begin{itemize}
	\item Ein \gls{polynomialzeit_verifizierer} für das Problem ist vorhanden.
	\item Ein anderes bekanntes NP-vollständiges Problem ist auf dieses Problem reduzierbar.
\end{itemize}

\subsection{$P = NP$?}
Die \autoref{fig:complexity_overview} zeigt die Aufteilung der verschiedenen Komplexitätsklassen für die beiden Fälle $P \neq NP$ und $P=NP$. Momentan wird davon ausgegangen, 
dass $P \neq NP$ ist und somit die linke Aufteilung stimmt. Keine der beiden Behauptungen konnte bis jetzt bewiesen werden. Der letzte Versuch, $P \neq NP$ zu beweisen, wurde von 
Vinay Deolalikar im Jahr 2010 unternommen \cite{p_neq_np_paper}. In diesem Versuch wurden jedoch zwei Fehler entdeckt (siehe \cite{p_neq_np_paper_blog}) und somit bleibt der 
Beweis weiter offen.

\begin{figure}[h]
\includegraphics[scale=0.65]{images/einleitung/p_np_np-complete_np-hard.png}
\caption[Übersicht der Komplexitätsklassen ($P!=NP$ und $P=NP$)]{Übersicht der Komplexitätsklassen ($P \neq NP$ und $P=NP$) (Grafik entnommen aus \cite{pic_p_np})}
\label{fig:complexity_overview}
\end{figure}

\section{Algorithmentypen}\label{algo_types}

\subsection{Backtracking Algorithmen}\label{backtracking_algos}
Beim Backtracking geht es darum, sich einer Lösung eines Problems schrittweise zu nähern. Bei jedem neuen Schritt wird geprüft, ob das Resultat noch eine gültige Lösung darstellt. Falls dies 
nicht der Fall ist, wird der letzte Schritt rückgängig gemacht und es wird ein anderer Weg eingeschlagen. In \cite{backtracking} wird dieses Verfahren anhand des Damenproblems aufgezeigt.

\subsection{Greedy Algorithmen}\label{greedy_algos}
Greedy Algorithmen liefern oft eine schnelle Lösung, welche aber meist nicht optimal ist. Die Algorithmen entscheiden bei jedem Schritt, was die aktuell beste Möglichkeit ist. Da sie nicht alle 
Möglichkeiten betrachten, finden sie oft nur ein lokales Minimum bzw. Maximum. In \autoref{fig:greedy_algo} ist in grün der Weg des Greedy Algorithmus zu sehen. Der Algorithmus entscheidet 
sich für die 12 auf der zweiten Ebene, da diese im Betrachtungsraum als beste Lösung gilt. Mit dem violetten Pfad könnte jedoch ein viel höherer Wert erzielt werden.

\begin{figure}[h]
\centering 
\includegraphics[scale=1]{images/einleitung/greedy_algo.png}
\caption[Suchablauf eines Greedy Algorithmus]{Suchablauf eines Greedy Algorithmus \selfmade{, Daten entnommen aus \cite{pic_greedy_algo}}}
\label{fig:greedy_algo}
\end{figure}

\FloatBarrier

\subsection{Evolutionäre Algorithmen}\label{ea_algos}
Evolutionäre Algorithmen nähern sich einer optimalen Lösung an. Sie basieren auf Kombinationen von Objekten und einer Fitnessfunktion zur Bewertung der einzelnen Generationen. 
Ein Ablauf eines Evolutionären Algorithmus sieht meist wie folgt aus:
\begin{enumerate}
	\item Initialisierung: Die erste Generation wird meist zufällig erzeugt
	\item Iteration durch folgende Schritte, bis die Lösung den gewünschten Wert erreicht hat:
     	\begin{enumerate}
		\item Evaluation: Mit Hilfe der Fitnessfunktion wird die erstellte Generation bewertet
         		\item Selektion: Auswahl von Objekten (Individuen) für die Rekombination
         		\item Rekombination: Erstellen einer neuen Generation durch die Kombination der ausgewählten Individuen
         		\item Mutation: Veränderung der Eigenschaften (Gene) der Nachfahren
      	\end{enumerate}
\end{enumerate}
Die Mutation und Rekombination können positive, negative oder neutrale Eigenschaften haben. Wie in der Natur überlebt der am besten Angepasste und somit wird die Lösung immer besser.
